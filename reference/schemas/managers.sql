--
-- Managers RBAC Schema
-- Implements custom claims and role-based access control for manager accounts
-- Based on Supabase custom claims and RBAC pattern
--

-- ============================================================================
-- CUSTOM TYPES
-- ============================================================================

-- Manager roles with clear hierarchy
CREATE TYPE public.manager_role AS ENUM (
  'super_admin',
  'content_manager',
  'support_manager',
  'finance_manager',
  'developer_manager'
);

COMMENT ON TYPE public.manager_role IS 'Hierarchy of manager roles with different permission levels';

-- Granular permissions for fine-grained access control
CREATE TYPE public.manager_permission AS ENUM (
  'managers.create',
  'managers.view',
  'managers.update',
  'managers.delete',
  'content.moderate',
  'content.approve',
  'content.feature',
  'content.delete',
  'users.view_details',
  'users.suspend',
  'users.reactivate',
  'users.view_analytics',
  'transactions.view',
  'transactions.refund',
  'payouts.approve',
  'payouts.process',
  'support.tickets.view',
  'support.tickets.respond',
  'support.tickets.escalate',
  'support.tickets.close',
  'developers.create',
  'developers.view',
  'developers.update',
  'developers.delete'
);

COMMENT ON TYPE public.manager_permission IS 'Granular permissions for role-based access control';

-- Manager account status
CREATE TYPE public.manager_status AS ENUM ('ACTIVE', 'INACTIVE', 'SUSPENDED');

COMMENT ON TYPE public.manager_status IS 'Status of a manager account';

-- ============================================================================
-- TABLES
-- ============================================================================

CREATE TABLE public.managers (
  id            UUID REFERENCES auth.users NOT NULL PRIMARY KEY,
  full_name     TEXT,
  email         TEXT NOT NULL,
  department    TEXT,
  bio           TEXT,
  avatar_url    TEXT,
  phone         TEXT,
  status        manager_status DEFAULT 'ACTIVE'::public.manager_status,
  last_login_at TIMESTAMPTZ,
  created_by    UUID REFERENCES auth.users,
  created_at    TIMESTAMPTZ DEFAULT timezone('utc'::TEXT, now()) NOT NULL,
  updated_at    TIMESTAMPTZ DEFAULT timezone('utc'::TEXT, now()) NOT NULL
);

COMMENT ON TABLE public.managers IS 'Profile data for manager accounts';
COMMENT ON COLUMN public.managers.id IS 'References the internal Supabase Auth user';

CREATE TABLE public.manager_user_roles (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id     UUID REFERENCES public.managers ON DELETE CASCADE NOT NULL,
  role        manager_role NOT NULL,
  assigned_by UUID REFERENCES auth.users,
  assigned_at TIMESTAMPTZ DEFAULT timezone('utc'::TEXT, now()) NOT NULL,
  UNIQUE (user_id, role)
);

COMMENT ON TABLE public.manager_user_roles IS 'Maps manager users to their assigned roles';

CREATE TABLE public.manager_role_permissions (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role        manager_role NOT NULL,
  permission  manager_permission NOT NULL,
  UNIQUE (role, permission)
);

COMMENT ON TABLE public.manager_role_permissions IS 'Defines permissions granted to each manager role';

-- ============================================================================
-- INDEXES
-- ============================================================================

-- Enable pg_trgm extension for trigram-based text search (required for ILIKE with wildcards)
CREATE EXTENSION IF NOT EXISTS pg_trgm;

CREATE INDEX idx_managers_id ON public.managers(id);
CREATE INDEX idx_managers_status ON public.managers(status);
CREATE INDEX idx_managers_created_by ON public.managers(created_by);

-- Trigram indexes for case-insensitive text search with ILIKE and wildcards
-- These dramatically improve performance for search queries with leading/trailing wildcards
CREATE INDEX idx_managers_email_trgm ON public.managers USING gin (email gin_trgm_ops);
CREATE INDEX idx_managers_full_name_trgm ON public.managers USING gin (full_name gin_trgm_ops);

CREATE INDEX idx_manager_user_roles_user_id ON public.manager_user_roles(user_id);
CREATE INDEX idx_manager_user_roles_role ON public.manager_user_roles(role);

CREATE INDEX idx_manager_role_permissions_role ON public.manager_role_permissions(role);

-- ============================================================================
-- FUNCTIONS
-- ============================================================================

CREATE OR REPLACE FUNCTION public.authorize_manager(
  requested_permission manager_permission
)
RETURNS BOOLEAN
AS $$
DECLARE
  bind_permissions INT;
  manager_role public.manager_role;
BEGIN
  -- Fetch manager role once and store it to reduce number of calls
  select (auth.jwt() ->> 'manager_role')::public.manager_role into manager_role;

  SELECT COUNT(*)
  INTO bind_permissions
  FROM public.manager_role_permissions
  WHERE manager_role_permissions.permission = requested_permission
    AND manager_role_permissions.role = manager_role;

  RETURN bind_permissions > 0;
END;
$$ language plpgsql stable security definer set search_path = '';

COMMENT ON FUNCTION public.authorize_manager(manager_permission) IS
  'Checks if current user has requested permission based on their manager role';

CREATE OR REPLACE FUNCTION public.create_manager(
  manager_email TEXT,
  manager_full_name TEXT,
  manager_role manager_role,
  manager_department TEXT DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  new_user_id UUID;
  creator_id UUID;
BEGIN
  creator_id := auth.uid();

  new_user_id := extensions.uuid_generate_v4();

  INSERT INTO auth.users (id, email, email_confirmed_at)
  VALUES (new_user_id, manager_email, timezone('utc'::TEXT, now()));

  INSERT INTO public.managers (id, full_name, email, department, created_by)
  VALUES (new_user_id, manager_full_name, manager_email, manager_department, creator_id);

  INSERT INTO public.manager_user_roles (user_id, role, assigned_by)
  VALUES (new_user_id, manager_role, creator_id);

  RETURN new_user_id;
END;
$$;

COMMENT ON FUNCTION public.create_manager(TEXT, TEXT, manager_role, TEXT) IS
  'Creates a new manager account with specified role (service role only)';

CREATE OR REPLACE FUNCTION public.is_manager(user_email TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.managers
    WHERE email = LOWER(user_email)
      AND status = 'ACTIVE'
  );
END;
$$;

COMMENT ON FUNCTION public.is_manager(TEXT) IS
  'Checks if an email belongs to an active manager account. Used for admin panel authentication.';


-- ============================================================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================================================

ALTER TABLE public.managers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.manager_user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.manager_role_permissions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Managers: Self view or authorized managers"
ON public.managers FOR SELECT
TO authenticated
USING (
  id = (SELECT auth.uid())
  OR (SELECT authorize_manager('managers.view'))
);

CREATE POLICY "Managers: authorized managers insert only"
ON public.managers FOR INSERT
TO authenticated
WITH CHECK (
  authorize_manager('managers.create')
);

CREATE POLICY "Managers: Self or authorized update"
ON public.managers FOR UPDATE
TO authenticated
USING (
  id = (SELECT auth.uid())
  OR (SELECT authorize_manager('managers.update'))
);

CREATE POLICY "Managers: Authorized delete only"
ON public.managers FOR DELETE
TO authenticated
USING (
  (SELECT authorize_manager('managers.delete'))
);

CREATE POLICY "Manager Roles: Individual read access"
ON public.manager_user_roles FOR SELECT
USING (
  user_id = (SELECT auth.uid())
);

-- ============================================================================
-- TRIGGERS
-- ============================================================================

CREATE TRIGGER on_manager_updated BEFORE UPDATE ON public.managers FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
CREATE TRIGGER on_manager_user_roles_updated BEFORE UPDATE ON public.manager_user_roles FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- ============================================================================
-- AUTH HOOK
-- ============================================================================

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims JSONB;
  user_role public.manager_role;
BEGIN
  SELECT role INTO user_role
  FROM public.manager_user_roles
  WHERE user_id = (event ->> 'user_id')::UUID
  LIMIT 1;

  claims := event -> 'claims';

  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{manager_role}', to_jsonb(user_role));
  ELSE
    claims := jsonb_set(claims, '{manager_role}', 'null');
  END IF;

  event := jsonb_set(event, '{claims}', claims);

  RETURN event;
END;
$$;

COMMENT ON FUNCTION public.custom_access_token_hook(JSONB) IS
  'Adds manager_role claim to JWT access tokens';

-- ============================================================================
-- GRANTS FOR AUTH HOOK
-- ============================================================================

GRANT USAGE ON SCHEMA public TO supabase_auth_admin;

GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;

REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

GRANT ALL ON TABLE public.manager_user_roles TO supabase_auth_admin;

REVOKE ALL ON TABLE public.manager_user_roles FROM authenticated, anon, public;

CREATE POLICY "Allow auth admin to read manager roles"
ON public.manager_user_roles
AS PERMISSIVE FOR SELECT
TO supabase_auth_admin
USING (true);
